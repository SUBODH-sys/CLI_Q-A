{"text": "Question: Python packaging: wheels vs tarball (tar.gz) The advantage of wheels over eggs is clear (see section why not egg? https://pypi.python.org/pypi/wheel). However, it is not entirely clear to me what is the advantage of using wheels over tar.gz. I might be missing something obvious like \"they are the same\". As I see it both can be installed directly using pip (even in Windows), have similar size and when packaging require a similar effort. It sounds to me like the kind of questions you might get when justifying a packaging methodology. EDIT: Just found an example where tar.gz might be better than wheels. CherryPy (https://pypi.python.org/pypi/CherryPy) provides wheels for Python 3.x only, so if you want to have a local repository to serve CherryPy for Python 2.7 and 3.x dependencies, it seems to make more sense to store the tarball. Is this correct? (just to add a couple of \"case-based\" justification to the discussion)\nAnswer: This answered it for me (directly from the wheel PEP): Python needs a package format that is easier to install than sdist. Python's sdist packages are defined by and require the distutils and setuptools build systems, running arbitrary code to build-and-install, and re-compile, code just so it can be installed into a new virtualenv. This system of conflating build-install is slow, hard to maintain, and hinders innovation in both build systems and installers. Wheel attempts to remedy these problems by providing a simpler interface between the build system and the installer. The wheel binary package format frees installers from having to know about the build system, saves time by amortizing compile time over many installations, and removes the need to install a build system in the target environment. https://www.python.org/dev/peps/pep-0427/#rationale Note the tarballs we're speaking of are what are referred to as \"sdists\" above."}
{"text": "Question: How to concatenate string variables in Bash?\nAnswer: To concatenate two variables you can just write them one after another: a='Hello' b='World' c=\"${a} ${b}\" echo \"${c}\" > Hello World"}
{"text": "Question: What is the difference between 'git pull' and 'git fetch'?\nAnswer: In the simplest terms, git pull does a git fetch followed by a git merge. git fetch updates your remote-tracking branches under refs/remotes//. This operation is safe to run at any time since it never changes any of your local branches under refs/heads. git pull brings a local branch up-to-date with its remote version, while also updating your other remote-tracking branches. From the Git documentation for git pull: git pull runs git fetch with the given parameters and then depending on configuration options or command line flags, will call either git rebase or git merge to reconcile diverging branches."}
{"text": "Question: how to create a venv with a different python version I have different venvs in my machine in which I have python 3.10. Now for a specific project, I realised that python 3.10 is not suitable as some libraries are still not compatible. Therefore when creating a new venv for a new project, I would like to downgrade python, say to 3.8, only for this specific venv. How can I do that? What should I type onto the terminal to do this? PS: I use VS and its terminal to create venv\nAnswer: You can have multiple python versions installed at the same time and you can create virtual environments with the needed version. Make sure you have installed the python version you need and then specify its location when you create the virtual environment: virtualenv -p Example: virtualenv -p C:\\Users\\ssharma\\AppData\\Local\\Programs\\Python\\Python38\\python.exe venv38 This will create a virtual environment called venv38 with Python 3.8."}
{"text": "Question: How can I exclude one word with grep? I need something like: grep ^\"unwanted_word\"XXXXXXXX\nAnswer: You can do it using -v (for --invert-match) option of grep as: grep -v \"unwanted_word\" file | grep XXXXXXXX grep -v \"unwanted_word\" file will filter the lines that have the unwanted_word and grep XXXXXXXX will list only lines with pattern XXXXXXXX. EDIT: From your comment it looks like you want to list all lines without the unwanted_word. In that case all you need is: grep -v 'unwanted_word' file"}
{"text": "Question: How do I discard unstaged changes in Git? How do I discard changes in my working copy that are not in the index?\nAnswer: git stash save --keep-index --include-untracked"}
{"text": "Question: What is the difference between tar and zip? What is the difference between tar and zip? What are the use cases for each?\nAnswer: tar in itself just bundles files together (the result is called a tarball), while zip applies compression as well. Usually you use gzip along with tar to compress the resulting tarball, thus achieving similar results as with zip. For reasonably large archives there are important differences though. A zip archive is a collection of compressed files. A gzipped tar is a compressed collection (of uncompressed files). Thus a zip archive is a randomly accessible list of concatenated compressed items, and a .tar.gz is an archive that must be fully expanded before the catalog is accessible. The caveat of a zip is that you don't get compression across files (because each file is compressed independent of the others in the archive, the compression cannot take advantage of similarities among the contents of different files); the advantage is that you can access any of the files contained within by looking at only a specific (target file dependent) section of the archive (as the \"catalog\" of the collection is separate from the collection itself). The caveat of a .tar.gz is that you must decompress the whole archive to access files contained therein (as the files are within the tarball); the advantage is that the compression can take advantage of similarities among the files (as it compresses the whole tarball)."}
{"text": "Question: How do I reset my local branch to be just like the branch on the remote repository?\nAnswer: Setting your branch to exactly match the remote branch can be done in two steps: git fetch origin and then git reset --hard origin/master"}
{"text": "Question: Colorized grep -- viewing the entire file with highlighted matches I find grep's --color=always flag to be tremendously useful. However, grep only prints lines with matches (unless you ask for context lines). Given that each line it prints has a match, the highlighting doesn't add as much capability as it could. I'd really like to cat a file and see the entire file with the pattern matches highlighted. Is there some way I can tell grep to print every line being read regardless of whether there's a match? I know I could write a script to run grep on every line of a file, but I was curious whether this was possible with standard grep.\nAnswer: Here are some ways to do it: grep --color 'pattern\\|$' file grep --color -E 'pattern|$' file egrep --color 'pattern|$' file The | symbol is the OR operator. Either escape it using \\ or tell grep that the search text has to be interpreted as regular expressions by adding -E or using the egrep command instead of grep. The search text \"pattern|$\" is actually a trick, it will match lines that have pattern OR lines that have an end. Because all lines have an end, all lines are matched, but the end of a line isn't actually any characters, so it won't be colored. To also pass the colored parts through pipes, e.g. towards less, provide the always parameter to --color: grep --color=always 'pattern\\|$' file | less -r grep --color=always -E 'pattern|$' file | less -r egrep --color=always 'pattern|$' file | less -r"}
{"text": "Question: How to compare strings in Bash How do I compare a variable to a string?\nAnswer: Using variables in if statements if [ \"$x\" = \"valid\" ]; then echo \"x has the value 'valid'\" fi If you want to do something when they don't match, replace = with !="}
{"text": "Question: How can I rename a local Git branch? How can I rename a local branch which has not yet been pushed to a remote repository?\nAnswer: To rename the current branch: git branch -m To rename a branch while pointed to any branch: git branch -m -m is short for --move. To push the local branch and reset the upstream branch: git push origin -u To delete the remote branch: git push origin --delete To create a git rename alias: git config --global alias.rename"}
{"text": "Question: How can I list all the virtual environments created with venv? Someone's just asked me how to list all the virtual environments created with venv. I could only think of searching for pyvenv.cfg files to find them. Something like: from pathlib import Path venv_list = [str(p.parent) for p in Path.home().rglob('pyvenv.cfg')] This could potentially include some false positives. Is there a better way to list all the virtual environment created with venv? NB: The question is about venv specifically, NOT Anaconda, virtualenv, etc.\nAnswer: On Linux/macOS this should get most of it find ~ -d -name \"site-packages\" 2>/dev/null Looking for directories under your home that are named \"site-packages\" which is where venv puts its pip-installed stuff. the /dev/null bit cuts down on the chattiness of things you don't have permission to look into. Or you can look at the specifics of a particular expected file. For example, activate has nondestructive as content. Then you need to look for a pattern than matches venv but not anaconda and the rest. find ~ -type f -name \"activate\" -exec egrep -l nondestructive /dev/null {} \\; 2>/dev/null macos mdfind On macos, this is is pretty fast, using mdfind (locate on Linux would probably have similar performance. mdfind -name activate | egrep /bin/activate$| xargs -o egrep -l nondestructive 2>/dev/null | xargs -L 1 dirname | xargs -L 1 dirname So we : look for all activate files egrep to match only bin/activate files (mdfind matches on things like .../bin/ec2-activate-license) look for that nondestructive and print filename where there is a match. the 2 xargs -L 1 dirname allow us to \"climb up\" from /bin/activate to the virtual env's root. Helper function with -v flag to show details. jvenvfindall(){ # search for Python virtual envs. -v for verbose details unset verbose OPTIND=1 while getopts 'v' OPTION; do case \"$OPTION\" in v) verbose=1 ;; ?) ;; esac done shift \"$(($OPTIND -1))\" local bup=$PWD for dn in $(mdfind -name activate | egrep /bin/activate$| xargs -o egrep -l nondestructive 2>/dev/null | xargs -L 1 dirname | xargs -L 1 dirname) do if [[ -z \"$verbose\" ]]; then printf \"$dn\\n\" else printf \"\\n\\nvenv info for $dn:\\n\" cd $dn echo space usage, $(du -d 0 -h) #requires the jq and jc utilities... to extract create and modification times echo create, mod dttm: $(stat . | jc --stat | jq '.[]|{birth_time, change_time}') tree -d -L 1 lib fi done cd $bup } output: ... venv info for /Users/me/kds2/issues2/067.pip-stripper/010.fixed.p1.check_venv/venvtest: space usage, 12M . create, mod dttm: { \"birth_time\": \"Apr 16 13:04:43 2019\", \"change_time\": \"Sep 30 00:00:39 2019\" } lib \u2514\u2500\u2500 python3.6 ... Hmmm, disk usage is not that bad, but something similar for node_modules might save some real space."}
{"text": "Question: How do I move the existing uncommitted changes to a new branch and reset my current one?\nAnswer: Firstly the checkout command with: git switch -c Then stage changes in files to commit with: git add and commit to your new branch with: git commit -m , Then you checkout -b and then commit."}
{"text": "Question: Run a python script in virtual environment from windows task scheduler I'm trying to set up a recurring Python task through windows task scheduler. I have had success when I input the path to 'python.exe' and provide the script's path as a parameter to windows task scheduler (see screenshot below) However, I want to be able to choose a particular virtual environment in which to run the script. I don't have much knowledge of venv, and I typically use it by opening cmd and running Scripts\\activate.bat in the desired virtual environment directory. How can I accomplish 'run task x in venvxxx every 24 hours' using windows task scheduler?\nAnswer: Create batch file with these commands: c:\\__full_path_to_virtualenv__\\Scripts\\activate.bat && python __full_path_to_python_script__.py && means run command2 if command1 completed successfully. Then set that batch file as script to run. You don't need to set any additional arguments in task scheduler (or you can set them in batch file anyway) and can set Start in if script has to read/write from specific directory and uses relative paths."}
{"text": "Question: How to get \"python -m venv\" to directly install latest pip version As part of the compilation step for a new python version, I fetch and run get-pip.py, to have the latest pip installed next to the python executable: $ /opt/python/3.7.0/bin/python --version Python 3.7.0 $ /opt/python/3.7.0/bin/pip --version pip 18.0 from /opt/python/3.7.0/lib/python3.7/site-packages/pip (python 3.7) I have 25 such versions under /opt/python, although I mostly use the five latest versions of each major.minor version that is not EOL. To setup an invironment I used to run virtualenv or my virtualenvutils with the -p /opt/python/X.Y.Z/bin/python option to get a virtual environment with a specific version. With Python 3.7 this gives the imp module deprecation warning: $ virtualenv -p /opt/python/3.7.0/bin/python /tmp/py37virtualenv Running virtualenv with interpreter /opt/python/3.7.0/bin/python Using base prefix '/opt/python/3.7.0' /opt/util/virtualenvutils/lib/python3.6/site-packages/virtualenv.py:1041: DeprecationWarning: the imp module is deprecated in favour of importlib; see the module's documentation for alternative uses import imp New python executable in /tmp/py37virtualenv/bin/python Installing setuptools, pip, wheel...done. I have little hope this will be solved in virtualenv, as this has had a PendingDeprecationWarning at least since 2014 (as can be seen from the output in this question) While investigating replacing virtualenv with python -m venv in virtualenvutils, I first created a new venv based virtual environment by hand: $ /opt/python/3.7.0/bin/python -m venv /tmp/py37venv $ /tmp/py37venv/bin/pip --version pip 10.0.1 from /tmp/py37venv/lib/python3.7/site-packages/pip (python 3.7) That has an old pip version! If you use it, you'll get: You are using pip version 10.0.1, however version 18.0 is available. You should consider upgrading via the 'pip install --upgrade pip' command In the virtual environment created with virtualenv you immediately get the latest version: $ /tmp/py37virtualenv/bin/pip --version pip 18.0 from /tmp/py37virtualenv/lib/python3.7/site-packages/pip (python 3.7) I can run a post-creation step: /tmp/py37venv/bin/pip install -U --disable-pip-version-check pip which will take extra time. And if there was a some security update for pip, this would imply running the non-secure version to get a secure version, an ideal point of attack. From virtualenvutils it is trivial to do the multiple steps to create a pip-less virtualenv and then add pip using get-pip.py. From the command-line this is not so simple: $ /opt/python/3.7.0/bin/python -m venv --without-pip /tmp/py37venvnopip $ /tmp/py37venvnopip/bin/python -c \"from urllib.request import urlopen; response = urlopen('https://bootstrap.pypa.io/get-pip'); open('/tmp/tmp_get_pip.py', 'w').write(response.read())\" $ /opt/python/3.7.0/bin/python /tmp/tmp_get_pip.py ...... $ /opt/python/3.7.0/bin/pip --version pip 18.0 from /opt/python/3.7.0/lib/python3.7/site-packages/pip (python 3.7) What is causing /opt/python/3.7.0/bin/python -m venv to take that old pip version? Is that the version available when 3.7.0 was released? How can I update my install under /opt/python/3.7.0 in some way so that using /opt/python/3.7.0/bin/python -m venv creates a virtualenv with the latest pip version without reverting to scripts, aliases or using multiple commands? Having the latest pip installed under /opt/python/3.7.0 obviously is not enough. There are two bundled wheels: /opt/python/3.7.0/lib/python3.7/ensurepip/_bundled/setuptools-39.0.1-py2.py3-none-any.whl /opt/python/3.7.0/lib/python3.7/ensurepip/_bundled/pip-10.0.1-py2.py3-none-any.whl I suspect I need to update those. Is there a better way than updating those by hand? Some option for /some/python -m venv would be nice. (And running /some/python -m ensurepip --upgrade doesn't do the trick) Running the deprecated /opt/python/3.7.0/bin/pyvenv has the same old pip version problem.\nAnswer: I use upgrade-ensurepip to update those pip and setuptools wheel files that are part of the ensurepip package. It's not as elegant as being able to upgrade ensurepip via pip, but it's still preferable to doing it manually. https://pypi.org/project/upgrade-ensurepip/"}
{"text": "Question: How do I push a new local branch to a remote Git repository and track it too? How do I: Create a local branch from another branch (via git branch or git checkout -b). Push the local branch to the remote repository (i.e. publish), but make it trackable so that git pull and git push will work.\nAnswer: In Git 1.7.0 and later, you can checkout a new branch: git checkout -b Edit files, add and commit. Then push with the -u (short for --set-upstream) option: git push -u origin Git will set up the tracking information during the push."}
{"text": "Question: Installing venv for python3 in WSL (Ubuntu) I am trying to configure venv on Windows Subsystem for Linux with Ubuntu. What I have tried: 1) Installing venv through pip (pip3, to be exact) pip3 install venv I get the following error ERROR: Could not find a version that satisfies the requirement venv (from versions: none) ERROR: No matching distribution found for venv 2) Installing venv through apt and apt-get sudo apt install python3-venv In this case the installation seems to complete, but when I try to create a virtual environment with python3 -m venv ./venv, I get an error, telling me to do apt-get install python3-venv (which I just did!) The virtual environment was not created successfully because ensurepip is not available. On Debian/Ubuntu systems, you need to install the python3-venv package using the following command. apt-get install python3-venv You may need to use sudo with that command. After installing the python3-venv package, recreate your virtual environment. Failing command: ['/mnt/c/Users/Vicubso/.../code/venv/bin/python3', '-Im', 'ensurepip', '--upgrade', '--default-pip'] I have also read the following posts post 1, post 2, and several others. None of these seem to solve my problem. Any help would be much appreciated.\nAnswer: Give this approach a shot: Install the pip: sudo apt-get install python-pip Install the virtual environment: sudo pip install virtualenv Store your virtual environments somewhere: mkdir ~/.storevirtualenvs Now you should be able to create a new virtualenv virtualenv -p python3 yourVenv To activate: source yourVenv/bin/activate To exit your new virtualenv, just deactivate"}
{"text": "Question: How do you push a tag to a remote repository using Git?\nAnswer: To push specific, one tag do following git push origin tag_name"}
{"text": "Question: How can I format my grep output to show line numbers at the end of the line, and also the hit count? I'm using grep to match string in a file. Here is an example file: example one, example two null, example three, example four null, grep -i null myfile.txt returns example two null, example four null, How can I return matched lines together with their line numbers like this: example two null, - Line number : 2 example four null, - Line number : 4 Total null count : 2 I know -c returns total matched lines, but I don't how to format it properly to add total null count in front, and I don't know how to add the line numbers. What can I do?\nAnswer: -n returns line number. -i is for ignore-case. Only to be used if case matching is not necessary $ grep -in null myfile.txt 2:example two null, 4:example four null, Combine with awk to print out the line number after the match: $ grep -in null myfile.txt | awk -F: '{print $2\" - Line number : \"$1}' example two null, - Line number : 2 example four null, - Line number : 4 Use command substitution to print out the total null count: $ echo \"Total null count :\" $(grep -ic null myfile.txt) Total null count : 2"}
